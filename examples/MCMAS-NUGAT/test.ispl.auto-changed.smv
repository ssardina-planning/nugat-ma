MODULE b1

GAME

-- The protocol for the dining cryptographers (Chaum)
-- This file is automatically generated for 3 cryptographers

1  --  DinCrypt1
  VAR
    payer1 : {yes,no};
    coinleft1 : {head,tail};
    coinright1 : {head,tail};
    seedifferent1 : { empty, yes, no };
    actions1 : { sayequal, saydifferent, none };
  INIT
    payer1=yes & coinleft1=head & coinright1=head & seedifferent1=empty
  TRANS
   case
    (payer1=no & seedifferent1=yes): next(actions1) in {saydifferent};
    (payer1=no & seedifferent1=no) : next(actions1) in {sayequal};
    (payer1=yes & seedifferent1=yes): next(actions1) in {sayequal};
    (payer1=yes & seedifferent1=no) : next(actions1) in {saydifferent};
    TRUE: next(actions1) in {none};
   esac
  TRANS
    ( seedifferent1=empty & coinleft1=head & coinright1=head ) |
      ( seedifferent1=empty & coinleft1=tail & coinright1=tail ) -> next((seedifferent1=no));
  TRANS
    ( seedifferent1=empty & coinleft1=head & coinright1=tail ) |
      ( seedifferent1=empty & coinleft1=tail & coinright1=head ) -> next((seedifferent1=yes) );

2  --  DinCrypt2
  VAR
    payer2 : {yes,no};
    coinleft2 : {head,tail};
    coinright2 : {head,tail};
    seedifferent2 : { empty, yes, no };
    actions2 : { sayequal, saydifferent, none };
  INIT
    payer2=no & coinleft2=head & coinright2=head & seedifferent2=empty
  TRANS
   case
    (payer2=no & seedifferent2=yes): next(actions2) in {saydifferent};
    (payer2=no & seedifferent2=no) : next(actions2) in {sayequal};
    (payer2=yes & seedifferent2=yes): next(actions2) in {sayequal};
    (payer2=yes & seedifferent2=no) : next(actions2) in {saydifferent};
    TRUE: next(actions2) in {none};
   esac
  TRANS
    ( seedifferent2=empty & coinleft2=head & coinright2=head ) |
      ( seedifferent2=empty & coinleft2=tail & coinright2=tail ) -> next((seedifferent2=no));
  TRANS
    ( seedifferent2=empty & coinleft2=head & coinright2=tail ) |
      ( seedifferent2=empty & coinleft2=tail & coinright2=head ) -> next((seedifferent2=yes) );
  
3  --  DinCrypt3
  VAR
    payer3 : {yes,no};
    coinleft3 : {head,tail};
    coinright3 : {head,tail};
    seedifferent3 : { empty, yes, no };
    actions3 : { sayequal, saydifferent, none };
  INIT
      payer3=no & coinleft3=head & coinright3=head & seedifferent3=empty
  TRANS
   case
    (payer3=no & seedifferent3=yes): next(actions3) in {saydifferent};
    (payer3=no & seedifferent3=no) : next(actions3) in {sayequal};
    (payer3=yes & seedifferent3=yes): next(actions3) in {sayequal};
    (payer3=yes & seedifferent3=no) : next(actions3) in {saydifferent};
    TRUE: next(actions3) in {none};
   esac
  TRANS
    ( seedifferent3=empty & coinleft3=head & coinright3=head ) |
      ( seedifferent3=empty & coinleft3=tail & coinright3=tail ) -> next((seedifferent3=no));
  TRANS
    ( seedifferent3=empty & coinleft3=head & coinright3=tail ) |
      ( seedifferent3=empty & coinleft3=tail & coinright3=head ) -> next((seedifferent3=yes) );

  
4  --  Environment
  VAR
    numberofodd : { none, even, odd };
    c1paid : boolean;
    c2paid : boolean;
    c3paid : boolean;
    odde : boolean;
    evene : boolean;

    INIT
     (numberofodd=none);


  TRANS
    ( ( numberofodd=none) & (
(  actions1=sayequal &  actions2=saydifferent &  actions3=saydifferent )       |
(  actions1=saydifferent &  actions2=sayequal &  actions3=saydifferent )       |
(  actions1=saydifferent &  actions2=saydifferent &  actions3=sayequal )       |
(  actions1=sayequal &  actions2=sayequal &  actions3=sayequal ) ) ) -> next(numberofodd=even);
  TRANS
    ( ( numberofodd=none) & (
(  actions1=saydifferent &  actions2=saydifferent &  actions3=saydifferent )       |
(  actions1=sayequal &  actions2=sayequal &  actions3=saydifferent )       |
(  actions1=sayequal &  actions2=saydifferent &  actions3=sayequal )       |
(  actions1=saydifferent &  actions2=sayequal &  actions3=sayequal )  ) ) -> next(numberofodd=odd);

 TRANS -- Evaluation
  ( payer1=yes ) -> next(c1paid);
  TRANS
  ( payer2=yes ) -> next(c2paid);
  TRANS
  ( payer3=yes ) -> next(c3paid);
  TRANS
  ( numberofodd=odd) -> next(odde);
  TRANS
  ( numberofodd=even) -> next(evene);


ATLREACHTARGET (1) c2paid;
ATLREACHTARGET (1) c3paid;
ATLREACHTARGET (2) c1paid;
ATLREACHTARGET (2) c3paid;
ATLREACHTARGET (3) c1paid;
ATLREACHTARGET (3) c2paid;

